# -*- coding: utf-8 -*-
"""Lab_02_170042008.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1O5JL9Eyb9GndC8UjYfG0iICntHSYMNqb

<h1> Math 4544 Numerical Analysis Lab</h1>
<h2> Lab 02 <h2>

The Objectives of this weeks lab is to implement and understand different methods to find out the roots of non linear equation. At the successful completion of this lab you should be able to implement different methods of solving non linear equation and understand their basic workflow along with their performance comparison. 

Implement the follwoing methods in the lab. 
- Bisection method
- Newton-Raphson method
- False Position method
- Secand method

Go to  [matplotlib.pyplot tutorials](https://matplotlib.org/gallery/index.html#pyplot) for all kinds of help regarding plot.

### Task 01 : Bisection method ###
In this task you have to implement the body of the function `bisection__().` For more about the bisection method please visit [lecture note on bisection](http://mathforcollege.com/nm/mws/gen/03nle/mws_gen_nle_txt_bisection.pdf)
"""

from sympy import *
from numpy import *
from math import *
import numpy as np
import matplotlib.pyplot as plt

x=Symbol('x')
eq=np.e**x+x**2+3*x+2
print(eq)
eq1=lambdify(x,eq)
print(eq1(-1.7874157307991467))

def bisection__(f,xl, xu, maxIter=20, threshold=0.2):
  array_of_values=[]
  array_of_approximations=[]

  for i in range(maxIter):
    value1=f(xl)
    value2=f(xu)
    xm=(xl+xu)/2
    #print(i,xm,value1,value2,xl,xu)
    array_of_values.append(xm)
    if (value1*f(xm)<0):
      xu=xm
    elif(value1*f(xm)>0):
      xl=xm
    elif(value1*f(xm)==0):
      break
    #error=(abs(xm-array_of_values[i-1])/xm)
    #array_of_approximations.append(error)

  #return array_of_approximations
  return array_of_values

# xl: lower bound of approximation
# xu: upper bound of approximation
# maxIter: maximum number of iterations
# threshold: threshold of error in percentage
# array_of_approximations: list of all approximation over 50 iterations

print(eq)
print(bisection__(eq1,-10,1))

"""### Task 02 : Newton Raphson Method ###
In this task you have to implement the body of the function` newton__().` For more about the bisection method please visit [lecture note on newton raphson method](https://nm.mathforcollege.com/mws/gen/03nle/mws_gen_nle_txt_newton.pdf)
"""

def newton__(fx,x0, maxIter=20, threshold=0.2):
  approx_values=[]
  array_of_approximations=[]
  Fx=lambdify(x,fx)

  fxPrime=fx.diff(x)
  FxPrime=lambdify(x,fxPrime)

  approx_values.append(x0)
  for i in range(maxIter):
    x1=x0-(Fx(x0)/FxPrime(x0))
    approx_values.append(x1)
    x0=x1
    
  return approx_values

# x0: initial approximation
# maxIter: maximum number of iterations
# threshold: threshold of error in percentage
# array_of_approximations: list of all approximation over 50 iterations

print(eq)
print(newton__(eq,0))

"""### Task 03 : False Position Method ###
In this task you have to implement the body of the function `falsePosition__().` For more about the  method please visit [lecture note on false position method](https://nm.mathforcollege.com/mws/gen/03nle/mws_gen_nle_ppt_falseposition.pdf)
"""

def falsePosition__(fx, xl, xu, maxIter=20, threshold=0.2):
  array_of_values=[]
  array_of_approximations=[]
  for i in range(maxIter):
    value1=fx(xl)
    value2=fx(xu)
    xm=((xu*value1)-(xl*value2))/(value1-value2)
    array_of_values.append(xm)
    if (value1*fx(xm)<0):
      xu=xm
    elif(value1*fx(xm)>0):
      xl=xm
    elif(value1*fx(xm)==0):
       break
  return array_of_values
# x0: initial approximation
# maxIter: maximum number of iterations
# threshold: threshold of error in percentage
# array_of_approximations: list of all approximation over 50 iterations

#print(eq(0))
print(falsePosition__(eq1, 0,1))

"""### Task 04 : Secant Method ###
In this task you have to implement the body of the function `secant__()`. For more about the  method please visit [lecture note on secant method](https://nm.mathforcollege.com/mws/gen/03nle/mws_gen_nle_ppt_secant.pdf)
"""

def secant__(fx, x0, maxIter=20, threshold=0.2):
  array_of_values=[]
  array_of_values.append(x0)
  x1=-1.0
  for i in range(maxIter):
    value1=fx(x0)
    value2=fx(x1)
    if(value1*value2==0):
      break
   # print(i,value1,x0,x1)
  #E  print(i,value2,x0,x1)
    x2=x0-((value1*(x0-x1))/(value1-value2))
    x0=x2
    array_of_values.append(x0)
    x1=array_of_values[i]
  return array_of_values
# x0: initial approximation
# maxIter: maximum number of iterations
# threshold: threshold of error in percentage
# array_of_approximations: list of all approximation over 50 iterations

#print(eq1(0)-eq1(-1))
#print(eq1(0))
print(secant__(eq1, 0))

"""### Task 05 : Calculate the relative approximate error ###
Implement the function `calc_error()` which takes a list of assumption as a list and returns a list of relative approximate values.
"""

def calc_error(assumptions):
  rel_approx_errors=[]
  length=len(assumptions)
  for i in range(0,length-1):
    error=abs(assumptions[i+1]-assumptions[i])/assumptions[i+1]
    rel_error=error*100
    rel_approx_errors.append(rel_error)
  return rel_approx_errors
# assumptions: list of assumptions returned by any previous method implemented successfully
# rel_approx_errors: list of calculated relative approximate error values. 
# ** make sure that you use absolute value here.

print(calc_error(secant__(eq1,0)))
print(calc_error(bisection__(eq1,-9,1)))
print(calc_error(newton__(eq,0)))
print(calc_error(falsePosition__(eq1,0,1)))

"""### Task 06: Ploting the errors###
Plot all the errors from the previous four methods in one graph to compare their comparative efficiency. Make sure that you use appropriate legend/labels in the plot to differentiate different curves.
"""

bisection__error=calc_error(bisection__(eq1,-9,1))
#newton_error=calc_error(newton__(eq,0))
#falsePosition_error=calc_error(falsePosition__(eq1,0,1))
#secant_error=calc_error(secant__(eq1,0))
print(len(bisection__error))
bisection_len=np.linspace(0,20)

plt.plot(np.array(bisection_len),np.array(bisection__error),'r')
plt.show()